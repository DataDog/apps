{"version":3,"sources":["webpack://framepost/webpack/universalModuleDefinition","webpack://framepost/webpack/bootstrap","webpack://framepost/./src/constants.ts","webpack://framepost/./src/logger.ts","webpack://framepost/./src/shared.ts","webpack://framepost/./src/utils.ts","webpack://framepost/./src/index.ts","webpack://framepost/./src/child.ts","webpack://framepost/./src/profiler.ts","webpack://framepost/./src/parent.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","MessageType","ProfileEventType","TransactionDirection","REQUEST_TIMEOUT","EVENT_TYPE_GET_PROFILE","getLogger","prefix","debug","log","message","console","error","profile","this","channel","defer","subscriptions","logger","profiler","getProfiler","messageListener","addEventListener","promise","then","eventType","data","requestId","postMessage","SEND","handler","id","randomInsecureId","otherSubscriptions","requestKey","sentMessage","send","Promise","resolve","reject","timer","unsubscribe","on","response","clearTimeout","setTimeout","requestHandler","requestData","requestMessage","context","removeEventListener","type","source","origin","logEvent","POST_MESSAGE","event","isFromValidSource","values","forEach","isValidMessage","CHANNEL_INIT","establishChannel","handleEvent","RECEIVE_MESSAGE","res","rej","len","Array","map","Math","random","toString","join","profileTransactions","parentEvents","childEvents","receiveEventsByMessageID","items","getId","out","item","keyBy","concat","filter","transactions","getBaseTransaction","date","transaction","direction","DOWN","postTime","receiveEvent","receiveTime","duration","getTime","ev","push","UP","sort","a","b","ChildClient","ParentClient","SharedClient","options","super","parentContext","handleRequest","getEvents","events","Date","frame","url","URL","contentWindow","request"],"mappings":"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","file":"framepost.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"framepost\"] = factory();\n\telse\n\t\troot[\"framepost\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","export enum MessageType {\n    CHANNEL_INIT = 'channel_init',\n    SEND = 'send'\n}\n\nexport enum ProfileEventType {\n    POST_MESSAGE = 'post_message',\n    RECEIVE_MESSAGE = 'receive_message'\n}\n\nexport enum TransactionDirection {\n    UP = 'up',\n    DOWN = 'down'\n}\n\nexport const REQUEST_TIMEOUT = 10000;\n\nexport const EVENT_TYPE_GET_PROFILE = '_get_profile';\n","/* eslint-disable no-console */\nexport interface Logger {\n    log(message: string): void;\n    error(message: string): void;\n}\n\nexport const getLogger = (prefix: string, debug: boolean): Logger => {\n    if (debug) {\n        return {\n            log(message: string) {\n                return console.log(`${prefix}: ${message}`);\n            },\n            error(message: string) {\n                return console.error(`${prefix}: ${message}`);\n            }\n        };\n    } else {\n        return {\n            log() {},\n            error() {}\n        };\n    }\n};\n","import { MessageType, ProfileEventType, REQUEST_TIMEOUT } from './constants';\nimport { Logger } from './logger';\nimport { Profiler, getProfiler } from './profiler';\nimport type {\n    Deferred,\n    Message,\n    Channel,\n    EventHandler,\n    RequestHandler\n} from './types';\nimport { defer, randomInsecureId } from './utils';\n\nexport interface SharedClientOptions {\n    debug?: boolean;\n    profile?: boolean;\n}\n\nexport abstract class SharedClient<C> {\n    protected readonly debug: boolean;\n    protected readonly profile: boolean;\n    protected readonly channel: Deferred<Channel<C>>;\n    protected readonly logger: Logger;\n    protected readonly profiler: Profiler;\n    protected subscriptions: {\n        [eventType: string]: { [id: string]: EventHandler };\n    };\n\n    constructor({ debug = false, profile = false }: SharedClientOptions = {}) {\n        this.debug = debug;\n        this.profile = profile;\n        this.channel = defer();\n        this.subscriptions = {};\n\n        this.logger = this.getLogger();\n        this.profiler = getProfiler(profile);\n\n        this.messageListener = this.messageListener.bind(this);\n        window.addEventListener('message', this.messageListener);\n\n        this.logger.log('Client initialized. Listening for messages');\n\n        this.channel.promise.then(() => {\n            this.logger.log('Secure parent <-> child channel established');\n        });\n    }\n\n    protected abstract establishChannel(event: MessageEvent<Message<C>>): void;\n    protected abstract getLogger(): Logger;\n\n    async send<T = any>(\n        eventType: string,\n        data: T,\n        requestId?: string\n    ): Promise<Message<T>> {\n        return this.postMessage(MessageType.SEND, eventType, data, requestId);\n    }\n\n    on<T = any>(eventType: string, handler: EventHandler<T>): () => void {\n        if (!this.subscriptions[eventType]) {\n            this.subscriptions[eventType] = {};\n        }\n\n        const id = randomInsecureId(8);\n\n        this.subscriptions[eventType][id] = handler;\n\n        this.logger.log(`Registered handler for event \"${eventType}\"`);\n\n        return () => {\n            const { [id]: _, ...otherSubscriptions } = this.subscriptions[\n                eventType\n            ];\n\n            this.subscriptions[eventType] = otherSubscriptions;\n\n            this.logger.log(`Unsubscribed handler for event ${eventType}`);\n        };\n    }\n\n    async request<Q = any, R = any>(requestKey: string, data?: Q): Promise<R> {\n        const sentMessage = await this.send(requestKey, data);\n\n        return new Promise((resolve, reject) => {\n            let timer: ReturnType<typeof setTimeout>;\n\n            const tmpEventHandler = (response: R, message: Message<R>) => {\n                if (message.requestId === sentMessage.id) {\n                    clearTimeout(timer);\n\n                    resolve(response);\n                }\n            };\n\n            const unsubscribe = this.on(requestKey, tmpEventHandler);\n\n            timer = setTimeout(() => {\n                unsubscribe();\n                reject('Request timed out');\n            }, REQUEST_TIMEOUT);\n        });\n    }\n\n    handleRequest<Q = any, R = any>(\n        requestKey: string,\n        requestHandler: RequestHandler<Q, R>\n    ): () => void {\n        const eventHandler = async (\n            requestData: Q,\n            requestMessage: Message<Q>\n        ) => {\n            const response = await requestHandler(requestData);\n\n            this.send(requestKey, response, requestMessage.id);\n        };\n\n        return this.on(requestKey, eventHandler);\n    }\n\n    async getContext(): Promise<C> {\n        const { context } = await this.channel.promise;\n        return context;\n    }\n\n    destroy() {\n        window.removeEventListener('message', this.messageListener);\n    }\n\n    protected async postMessage<T = any>(\n        type: MessageType,\n        eventType: string,\n        data: T,\n        requestId?: string\n    ): Promise<Message<T>> {\n        const { source, origin } = await this.channel.promise;\n\n        const message: Message = {\n            type,\n            eventType,\n            data,\n            id: randomInsecureId(),\n            requestId\n        };\n\n        source.postMessage(message, origin);\n\n        this.logger.log(\n            `Sent message type \"${type}\", eventType: \"${eventType || 'none'}\"`\n        );\n\n        this.profiler.logEvent(ProfileEventType.POST_MESSAGE, message);\n\n        return message;\n    }\n\n    protected async isFromValidSource<T = any>(\n        event: MessageEvent<any>\n    ): Promise<boolean> {\n        const { source } = await this.channel.promise;\n\n        return event.source === source;\n    }\n\n    protected isValidMessage(event: MessageEvent<any>): boolean {\n        const message = event.data;\n\n        return message.type && message.id;\n    }\n\n    protected async handleEvent<T = any>(event: MessageEvent<any>) {\n        const valid = await this.isFromValidSource<T>(event);\n        if (valid) {\n            const message = event.data as Message<T>;\n\n            const subscriptions = this.subscriptions[message.eventType] || {};\n\n            Object.values(subscriptions).forEach(handler =>\n                handler(message.data, message)\n            );\n\n            this.logger.log(\n                `Triggered handlers for event type \"${message.eventType}\"`\n            );\n        }\n    }\n\n    protected messageListener(event: MessageEvent<Message>) {\n        if (!this.isValidMessage(event)) {\n            this.logger.error('Invalid message format. Skipping');\n\n            return;\n        }\n\n        switch (event.data.type) {\n            case MessageType.CHANNEL_INIT: {\n                this.establishChannel(event);\n                break;\n            }\n            case MessageType.SEND: {\n                this.handleEvent(event);\n            }\n        }\n\n        this.logger.log(\n            `Received message type \"${event.data.type}\", eventType: \"${\n                event.data.eventType || 'none'\n            }\"`\n        );\n\n        this.profiler.logEvent(ProfileEventType.RECEIVE_MESSAGE, event.data);\n    }\n}\n","import { ProfileEventType, TransactionDirection } from './constants';\nimport type { Deferred, ProfileEvent, TransactionProfile } from './types';\n\nexport const defer = <T>(): Deferred<T> => {\n    let resolve: (t: T) => void = () => {};\n    let reject: (e?: any) => void = () => {};\n    const promise = new Promise<T>((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n\n    return {\n        resolve,\n        reject,\n        promise\n    };\n};\n\n/* eslint-disable no-bitwise */\nexport const randomInsecureId = (len: number = 16): string =>\n    [...Array(len)].map(() => (~~(Math.random() * 36)).toString(36)).join('');\n/* eslint-enable */\n\nconst keyBy = <T>(\n    items: T[],\n    getId: (item: T) => string\n): { [key: string]: T } => {\n    const out: { [key: string]: T } = {};\n\n    items.forEach(item => {\n        out[getId(item)] = item;\n    });\n\n    return out;\n};\n\nexport const profileTransactions = (\n    parentEvents: ProfileEvent[],\n    childEvents: ProfileEvent[]\n): TransactionProfile[] => {\n    const allEvents = parentEvents.concat(childEvents);\n    const receiveEvents = allEvents.filter(\n        item => item.type === ProfileEventType.RECEIVE_MESSAGE\n    );\n    const receiveEventsByMessageID = keyBy(\n        receiveEvents,\n        item => item.message.id\n    );\n\n    const transactions: TransactionProfile[] = [];\n\n    const getBaseTransaction = ({\n        date,\n        message\n    }: ProfileEvent): TransactionProfile => {\n        const transaction: TransactionProfile = {\n            id: message.id,\n            direction: TransactionDirection.DOWN,\n            postTime: date,\n            message\n        };\n\n        const receiveEvent = receiveEventsByMessageID[message.id];\n\n        if (receiveEvent) {\n            transaction.receiveTime = receiveEvent.date;\n            transaction.duration =\n                (receiveEvent.date.getTime() - date.getTime()) / 1000;\n        }\n\n        return transaction;\n    };\n\n    parentEvents\n        .filter(item => item.type === ProfileEventType.POST_MESSAGE)\n        .forEach(ev => {\n            const transaction = getBaseTransaction(ev);\n\n            transactions.push(transaction);\n        });\n\n    childEvents\n        .filter(item => item.type === ProfileEventType.POST_MESSAGE)\n        .forEach(ev => {\n            const transaction = getBaseTransaction(ev);\n\n            transaction.direction = TransactionDirection.UP;\n\n            transactions.push(transaction);\n        });\n\n    return transactions.sort(\n        (a, b) => a.postTime.getTime() - b.postTime.getTime()\n    );\n};\n","export { ChildClient } from './child';\nexport { ParentClient } from './parent';\n","import { MessageType, EVENT_TYPE_GET_PROFILE } from './constants';\nimport { getLogger } from './logger';\nimport { SharedClient, SharedClientOptions } from './shared';\nimport type { Message, Channel } from './types';\n\nexport interface ChildClientOptions extends SharedClientOptions {\n    parentContext: any;\n}\nexport class ChildClient<C = any> extends SharedClient<C> {\n    parentContext: any;\n\n    constructor(options: ChildClientOptions) {\n        super(options);\n\n        this.parentContext = options.parentContext || null;\n\n        if (this.profile) {\n            this.handleRequest(EVENT_TYPE_GET_PROFILE, () =>\n                this.profiler.getEvents()\n            );\n        }\n    }\n\n    protected getLogger() {\n        return getLogger('child-client', this.debug);\n    }\n\n    protected establishChannel(event: MessageEvent<Message<C>>) {\n        const channel: Channel = {\n            source: event.source as Window,\n            origin: event.origin,\n            context: event.data.data\n        };\n        this.channel.resolve(channel);\n        this.postMessage(MessageType.CHANNEL_INIT, '', this.parentContext);\n    }\n}\n","import { ProfileEventType } from './constants';\nimport type { ProfileEvent, Message } from './types';\n\nexport interface Profiler {\n    logEvent(type: ProfileEventType, message: Message): void;\n    getEvents(): ProfileEvent[];\n}\n\nexport const getProfiler = (profile: boolean): Profiler => {\n    const events: ProfileEvent[] = [];\n\n    return {\n        logEvent(type: ProfileEventType, message: Message) {\n            if (profile) {\n                events.push({\n                    type,\n                    message,\n                    date: new Date()\n                });\n            }\n        },\n        getEvents() {\n            return events;\n        }\n    };\n};\n","import { MessageType, EVENT_TYPE_GET_PROFILE } from './constants';\nimport { getLogger } from './logger';\nimport { SharedClient, SharedClientOptions } from './shared';\nimport type {\n    Message,\n    Channel,\n    ProfileEvent,\n    TransactionProfile\n} from './types';\nimport { randomInsecureId, profileTransactions } from './utils';\n\nexport interface ParentClientOptions extends SharedClientOptions {}\n\nexport class ParentClient<C = any> extends SharedClient<C> {\n    private frame?: HTMLIFrameElement;\n    private url?: URL;\n\n    constructor(options: ParentClientOptions) {\n        super(options);\n    }\n\n    requestChannel<T>(frame: HTMLIFrameElement, url: string, context: T) {\n        this.frame = frame;\n        this.url = new URL(url);\n\n        if (frame.contentWindow) {\n            const message: Message = {\n                type: MessageType.CHANNEL_INIT,\n                eventType: '',\n                data: context,\n                id: randomInsecureId()\n            };\n\n            frame.contentWindow.postMessage(message, this.url.origin);\n        }\n    }\n\n    async getProfile(): Promise<TransactionProfile[]> {\n        const childEvents = await this.request<any, ProfileEvent[]>(\n            EVENT_TYPE_GET_PROFILE\n        );\n        const events = this.profiler.getEvents();\n\n        return profileTransactions(events, childEvents);\n    }\n\n    protected establishChannel(event: MessageEvent<Message<C>>) {\n        if (this.frame && event.source === this.frame.contentWindow) {\n            const channel: Channel<C> = {\n                source: event.source as Window,\n                origin: event.origin,\n                context: event.data.data\n            };\n\n            this.channel.resolve(channel);\n        }\n    }\n\n    protected getLogger() {\n        return getLogger('parent-client', this.debug);\n    }\n}\n"],"sourceRoot":""}